不是必须遵循的教条，而是 总结出的经验和参考方案。

它们利用了 面向对象的特性（封装、继承、多态、接口抽象、组合等）来解决常见问题。

目的是 让代码更可维护、更易扩展，减少重复劳动。

创建型模式
1，单例模式：
	构造函数，拷贝构造私有；类内创建唯一私有对象，通过静态的方法访问。
	懒汉模式：用到时创建，饿汉模式：类加载时进行示例化。
2，简单工厂模式：
	产品抽象类->具体的产品类，通过一个工厂类+传入一个参数来创建具体的产品对象（传入类型可以传入枚举类型）。
3，工厂模式：
	简单工厂模式违反开放封闭原则，添加产品需要修改工厂创建产品方法增加switch分支。
	在简单工厂的基础上添加工厂基类，多个子类继承自工厂基类分别创建不同的产品。
4，抽象工厂模式：
	产品需要通过不同的属性不同品类来搭配组合成一个具体的产品。
	抽象属性1->属性1品质优/属性1品质良/属性1品质差
	抽象属性2->属性2品质优/属性2品质良/属性2品质差
	抽象属性3->属性3品质优/属性3品质良/属性3品质差
	产片类对象通过不同属性来创建
	工厂基类->具体产品工厂类
5,生成器模式：
	产品
	产品生成器基类->产品1生成器/产品2生成器
	指挥者，指挥者中通过生成器生成产品
6，原型模式：（子类克隆）
	基类指针指向子类对象，对象之间克隆。拷贝构造无法实现。
	通过复制现有对象来创建新对象，而不是通过实例化类。
	
	对象的创建成本较高（如对象、复杂初始化）。
	避免大量重复的初始化代码。
	系统中要保存对象的状态，并在未来某个时刻重新生成（如编辑器中的“撤销/恢复”功能）。
	需要在运行时动态决定实例的类型

结构型模式	
1，适配器模式：（翻译官）
	主要解决接口不兼容的问题。它的作用就像生活中的“电源适配器”，把一个接口转换成客户端所期望的另一个接口，从而使得原本因为接口不匹配而不能一起工作的类可以协同工作。
	角色：目标接口，适配者，适配器
2，桥接模式：（分离抽象与实现）
	将抽象部分与实现部分分离，使它们能够独立地变化。
	在软件设计中，常常遇到“类的维度扩展”问题。比如：
	如果有一个 图形类，图形可能有不同的形状（圆形、矩形…），同时还有不同的颜色（红、蓝…）。
	如果直接用继承，可能要写：红色圆形、蓝色圆形、红色矩形、蓝色矩形……组合多了类爆炸。
	桥接模式的解决方法：把“形状”与“颜色”两个维度分开，让它们通过“桥”联系。这样形状和颜色都能独立扩展，不会造成类的爆炸。
	角色：抽象类->扩充抽象类，实现接口（抽象）->具体实现
3，组合模式：（树状结构）
	表示树形结构，如文件系统、公司组织结构。
	客户端需要一致地处理单个对象和组合对象。
	对象的“整体-部分”关系清晰。
	角色：节点->叶子节点+非叶子节点
4，装饰模式：（层层装饰，层层加码）
	在不改变原有对象的基础上，动态地为对象添加新的功能。这比继承更加灵活，因为继承是静态的扩展，而装饰模式是运行时动态的扩展。
	角色：抽象构建->具体构件+抽象装饰（抽象）-》具体装饰
5，外观模式：
	将复杂的子系统包装起来，只需要与包装起来的外观打交道。
	角色：若干子系统，外观（若干子系统）
6，享元模式：（对象共享缓存）
	摒弃了在每个对象中都保存所有的数据的这种方式，通过数据共享（缓存）让有限的内存可以加载更多的对象。
	角色：抽象享元（外部状态）->具体享元（内部状态），享元工厂（具体享元）
7，代理模式：（话事人）
	代理占位，由代理控制对象访问。
	角色：抽象主题->真实主题+代理(抽象主题）
行为模式
1，责任链模式：（请求传递）
	将处理事件沿着链条传递下去，传递到处理该事件的处理者处理事件
	角色：抽象处理者->具体处理者+...
2，命令模式：
	分离发送命令者与执行命令者
	角色：调用者，执行者，抽象命令->具体命令
3，迭代器模式：stl迭代器
4，中介模式：
	对象之间不在显示的互相引用，通过中介交互
	角色：抽象中介->具体中介（具体同事），抽象同事（抽象中介）->具体同事
5，备忘录模式：
	保存对象状态到备忘录，便于恢复
	角色：发起人，备忘录，备忘录管理者
6，观察者模式：
	建立一对多的依赖关系，主题改变时通知多有的对象更新
	角色：主题->具体主题，观察者->具体观察者
7，策略模式：
	定义一系列算法，分别把他们封装起来根据环境替换
	角色：抽象策略->具体策略，环境角色（抽象策略）
8，状态模式：
	内部设置状态，类似于策略模式
9，模板方法：
	子类在不改变整体结构的情况下，重写部分步骤。
	角色：抽象类（模板+步骤）->具体类（重写部分步骤）

	